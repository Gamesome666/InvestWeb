---
alwaysApply: true
---
## ❌ 负面标准（不应包含的内容）

**不要**包含：

- **一次性任务特定细节**：不能泛化的内容
- **实现细节**：不会被重用的内容
- **临时上下文**：以后不会相关的内容
- **纯粹来自助手聊天而非用户聊天的上下文**
- **仅适用于当前对话中讨论的特定文件、函数或代码片段的信息**：不具有广泛适用性
- **模糊或明显的偏好**：不可操作的内容
- **任何用户都想要的良好编程实践的一般性陈述**
- **基本软件工程原则**：如关注点分离、DRY、SOLID、YAGNI、KISS 等

---

## 🚫 不应记住的示例

### 示例记忆（错误）

1. **refactor-target**：`utils.ts` 中的 `calculateTotal` 函数需要重构。  
   *(特定于当前任务)*

2. **variable-name-choice**：在此特定函数中，对 API 调用的结果使用 'userData'。  
   *(实现细节)*

3. **api-endpoint-used**：此组件的数据来自 `/api/v2/items`。  
   *(特定于当前代码的上下文)*

4. **css-class-fix**：需要在此视图中的 `.card-title` 元素添加 `margin-top: 10px`。  
   *(高度特定的细节)*

5. **navigate-conversation-history**：用户经常需要实现导航对话历史的逻辑。  
   *(太模糊)*

6. **code-organization**：用户喜欢组织良好的代码。  
   *(太明显和模糊)*

7. **testing-important**：测试对用户很重要。  
   *(太明显)*

8. **error-handling**：用户想要良好的错误处理。  
   *(不可操作)*

9. **debugging-strategy**：倾向于将复杂问题分解为更小的部分，识别有问题的更改，并在尝试替代解决方案之前系统地还原它们。  
   *(描述了一种常见的、有点明显的调试方法)*

10. **basic-software-engineering-principles**：基本软件工程原则，如关注点分离、DRY、SOLID、YAGNI、KISS 等。  
    *(太明显和模糊)*

---

## 不要从不需要记忆的对话中生成记忆

### 场景示例 1：简单验证请求

**示例对话：**

```
用户：我只想在 side_model 是设置时才让这些东西工作，这个实现看起来合理吗？

助手：是的，这个实现看起来正确。
1. shouldRunOnBeforeSubmitChat 和 shouldRunOnComposerDone 方法正确地基于 memorySystem 设置来控制 onBeforeSubmitChat 和 onComposerDone 的执行。
2. 此外，onBeforeSubmitChat 和 checkForMemories（由 onComposerDone 调用）在开始时都有明确的检查，如果 memorySystem 不是 side-model 则提前返回。
这种双重检查确保核心逻辑仅在设置配置为 side-model 时运行。
```

**建议的记忆：**
```
settings-gating-pattern: 使用专用的门控方法（例如 shouldRun...）和核心逻辑函数内的显式检查来按设置门控功能。
```

**为什么这是一个糟糕的记忆：**

这个交互不需要记忆。用户的消息只是对当前任务的特定实现细节（`side-model` 检查）的验证请求。虽然助手提供了详细的解释，但用户并没有表达一般性偏好、规则、模式、强烈意见或挫折，这些对未来的交互有价值的内容。记忆应该源于重要的用户输入或交互模式，而不仅仅是对简单查询的详细助手响应。

---

### 场景示例 2：特定重构问题

**示例对话：**

```
用户：我正在重构 processUserInput 函数以拆分出验证逻辑。我应该在新的 validateInput 函数之前还是之后调用 sanitizeInput？

助手：最好在 validateInput 之前调用 sanitizeInput，这样在执行任何验证检查之前先清理输入。这确保验证在安全、规范化的数据上操作。
```

**建议的记忆：**
```
refactor-ordering: 在 processUserInput 函数中始终在 validateInput 之前调用 sanitizeInput。
```

**为什么这是一个糟糕的记忆：**

这是关于特定重构中函数调用顺序的一次性任务特定细节。用户并没有表达一般性偏好或工作流程，只是在寻求特定实现的建议。这不应该作为未来对话的一般规则被记住。

---

## ✅ 应该记住的示例

### 示例记忆（正确）

1. **function-size-preference**：保持函数在 50 行以下以保持可读性。  
   *(具体且可操作)*

2. **prefer-async-await**：使用 async/await 风格而不是 promise 链式调用。  
   *(影响代码的明确偏好)*

3. **typescript-strict-mode**：在 TypeScript 项目中始终启用 `strictNullChecks` 和 `noImplicitAny`。  
   *(具体配置)*

4. **test-driven-development**：在实现新功能之前先编写测试。  
   *(明确的工作流程偏好)*

5. **prefer-svelte**：对于新的 UI 工作，优先使用 Svelte 而不是 React。  
   *(明确的技术选择)*

6. **run-npm-install**：在运行终端命令之前运行 'npm install' 来安装依赖项。  
   *(具体的工作流程步骤)*

7. **frontend-layout**：代码库的前端使用 Tailwind CSS。  
   *(具体的技术选择)*

---

## 🏷️ 标签说明

- **标签应该描述被捕获的一般概念**
- **标签将用作文件名，只能包含字母和连字符**
- 使用小写字母和连字符分隔单词（例如：`function-size-preference`）

---

## 📋 格式化说明

以以下 JSON 格式返回您的响应：

```json
{
	"explanation": "在此解释，对于每个负面示例，为什么下面的记忆*不*违反任何负面标准。具体说明它避免了哪些负面标准。",
	"memory": "preference-name: 要记住的一般偏好或方法。不要包含当前对话的特定细节。保持简短，最多 3 句话。不要使用引用对话的示例。"
}
```

### 如果不需要记忆

如果不需要记忆，请准确返回：

```
no_memory_needed
```

---

## 总结

### 记忆提取的核心原则

#### ✅ **应该提取的记忆特征**
- 具体且可操作
- 通用且可重复应用
- 代表持久偏好而非临时需求
- 包含明确的技术选择或工作流程
- 用户明确表达或多次强调

#### ❌ **不应提取的内容特征**
- 仅与当前任务/文件相关
- 模糊或过于明显
- 临时的实现细节
- 基本的软件工程常识
- 仅来自助手而非用户的见解

### 判断标准

在决定是否提取记忆时，问自己：

1. **这个信息在未来的不同对话中有用吗？**
2. **它足够具体以指导行动吗？**
3. **它是用户的真实偏好还是一次性需求？**
4. **它超越了基本的编程常识吗？**

**关键原则**：宁可少记不可多记。只有真正有价值的、可重复使用的、具体的用户偏好才值得保存。

