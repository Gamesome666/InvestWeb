---
alwaysApply: true
---
## 值得记住的记忆特征

一个记忆值得被记住，如果它：

- **与编程和软件工程领域相关**
- **具有通用性，适用于未来的交互**
- **具体且可操作** - 模糊的偏好或观察应该得低分（分数：1-2）
- **不是特定任务细节、一次性请求或实现细节**（分数：1）
- **关键点**：它**不能**仅与当前对话中讨论的特定文件或代码片段相关。它必须代表一般性的偏好或规则。

**特别重要**：如果用户表达沫丧或纠正助手，这尤其重要需要捕获。

---

## 评分示例

### ❌ 应该**不被记住**的记忆（分数：1）

*通常因为它们与对话中的特定代码相关或是一次性细节*

#### 示例

- **refactor-target**：`utils.ts` 中的 `calculateTotal` 函数需要重构。  
  *(特定于当前任务)*

- **variable-name-choice**：在这个特定函数中，对 API 调用的结果使用 'userData'。  
  *(实现细节)*

- **api-endpoint-used**：此组件的数据来自 `/api/v2/items`。  
  *(特定于当前代码的上下文)*

- **css-class-fix**：需要在此视图中的 `.card-title` 元素添加 `margin-top: 10px`。  
  *(高度特定的细节)*

---

### ⚠️ **模糊**或**明显**的记忆（分数：2-3）

#### 示例

- **navigate-conversation-history**：用户经常需要实现导航对话历史的逻辑。  
  *(太模糊，不可操作 - 分数 1)*

- **code-organization**：用户喜欢组织良好的代码。  
  *(太明显和模糊 - 分数 1)*

- **testing-important**：测试对用户很重要。  
  *(太明显和模糊 - 分数 1)*

- **error-handling**：用户想要良好的错误处理。  
  *(太明显和模糊 - 分数 1)*

- **debugging-strategy**：倾向于将复杂问题分解为更小的部分，识别有问题的更改，并在尝试替代解决方案之前系统地还原它们。  
  *(描述了一种常见的、有点明显的调试方法 - 分数 2)*

- **separation-of-concerns**：倾向于通过将关注点分离为更小、更易管理的单元来重构复杂系统。  
  *(描述了一种常见的、有点明显的软件工程原则 - 分数 2)*

---

### 😐 **中等范围**的记忆（分数：3）

#### 示例

- **focus-on-cursor-and-openaiproxy**：用户经常请求帮助处理代码库或 ReactJS 代码库。  
  *(特定的代码库，但需要的帮助类型模糊)*

- **project-structure**：前端代码应该在 'components' 目录中，后端代码在 'services' 中。  
  *(项目特定的组织方式，有帮助但不是关键)*

---

### ✅ **应该被记住**的记忆（分数：4-5）

#### 示例

- **function-size-preference**：保持函数在 50 行以下以保持可读性。  
  *(具体且可操作 - 分数 4)*

- **prefer-async-await**：使用 async/await 风格而不是 promise 链式调用。  
  *(影响代码的明确偏好 - 分数 4)*

- **typescript-strict-mode**：在 TypeScript 项目中始终启用 `strictNullChecks` 和 `noImplicitAny`。  
  *(具体配置 - 分数 4)*

- **test-driven-development**：在实现新功能之前先编写测试。  
  *(明确的工作流程偏好 - 分数 5)*

- **prefer-svelte**：对于新的 UI 工作，优先使用 Svelte 而不是 React。  
  *(明确的技术选择 - 分数 5)*

- **run-npm-install**：在运行终端命令之前运行 'npm install' 来安装依赖项。  
  *(具体的工作流程步骤 - 分数 5)*

- **frontend-layout**：代码库的前端使用 Tailwind CSS。  
  *(具体的技术选择 - 分数 4)*

---

## 评分指导原则

### 重要原则

1. **倾向于给出较低评分**  
   用户在记忆评分过高时会**非常恼火**。

2. **特别关注模糊或明显的记忆**  
   将**模糊**或**明显**的记忆评为 **1 或 2**。这些最有可能是错误的。

3. **不确定时给 3 分**  
   如果不确定或记忆处于边界线，分配分数 3。

4. **只有明确有价值时才给 4-5 分**  
   只有当记忆明确是有价值的、可操作的、通用的偏好时，才分配 4 或 5。

5. **仅适用于特定代码/文件时给 1-2 分**  
   如果记忆**仅**适用于对话中讨论的特定代码/文件而不是通用规则，或者太模糊/明显，则分配分数 1 或 2。

### 特殊情况

- **用户明确要求记住**：无论如何都应分配 **5 分**

- **看到 "no_memory_needed" 或 "no_memory_suggested"**：**必须**分配 **1 分**

---

## 评分输出格式

### 输出要求

1. **提供评分理由**  
   主要基于为什么该记忆不属于应该被评为 1、2 或 3 的 99% 的记忆，特别关注它与负面示例有何不同。

2. **在新行上返回分数**  
   格式：`SCORE: [score]`  
   其中 `[score]` 是 1 到 5 之间的整数。

### 示例输出

```
理由：这个记忆具体说明了用户对函数大小的明确偏好（50行以下），这是一个可操作的、通用的编码标准，可以应用于所有未来的代码编写场景。与模糊的"代码组织良好"不同，这提供了具体的度量标准。它不是特定于某个文件或任务的，而是一个持久的编码风格偏好。

SCORE: 4
```

---

## 总结

这套评分系统旨在：

- **过滤掉特定任务的细节**（分数 1）
- **排除模糊或明显的观察**（分数 1-2）
- **保留可操作的通用偏好**（分数 4-5）
- **在不确定时保持谨慎**（分数 3）

**核心原则**：宁可低估也不要高估记忆的价值。只有真正有用的、具体的、可操作的、通用的偏好才值得高分。

